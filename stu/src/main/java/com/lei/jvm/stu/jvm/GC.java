package com.lei.jvm.stu.jvm;

/**
 * @Description
 * @Author leihaoyuan
 * @Date 2020/6/28 14:11
 * 【标记清除法】Mark-Sweep
 * 标记清除法先通过根节点标记所有的可达对象，然后清除所有的不可达对象，完成垃圾回收。
 *
 * 【复制算法】Copying
 * 复制算法比较适合新生代，因为在新生代垃圾对象通常会多于存活对象，复制算法的效果会比较好。
 *
 * 【标记压缩法】Mark-Compact
 * 和标记清除法一样，标记压缩法首先也需要从根节点开始，对所有可达对象做一次标记。
 * 但之后，它并不只是简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。然后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，性价比较高。
 *
 * 【分代算法】Generational Collecting
 *  没有一种算法可以完全替代其他算法，它们都有自己的优势和特点。根据垃圾回收对象的特性，使用合适的算法，才是明智的选择。分代算法就基于这种思想，它将内存区间根据对象的特点分成几块，根据每块内存区间的特点使用不同的回收算法，以提高垃圾回收的效率。
 *
 *
 *  -----------------------------------------------------------------------------------
 *  【卡表】Card Table
 *  根据卡表新生代GC只需扫描部分老年代
 *  对于新生代和老年代来说，通常新生代回收的频率很高，但是每次回收的耗时很短，而老年代回收的频率比较低，但是会消耗更多的时间。
 *  为了支持高频率的新生代回收，虚拟机可能使用一种叫作卡表（Card Table）的数据结构。
 *  卡表为一个比特位集合，每一个比特位可以用来表示老年代的某一区域中的所有对象是否持有新生代对象的引用。
 *  这样在新生代GC时，可以不用花大量时间扫描所有的老年代对象来确定每一个对象的引用关系，可以先扫描卡表，只有当卡表的标记位为1时，才需要扫描给定区域的老年代对象，而卡表位为0的老年代对象，一定不含有新生代对象的引用。
 *  卡表中每一位表示老年代4KB的空间，卡表记录为0的老年代区域没有任何对象指向新生代，只有卡表位为1的区域才有对象包含新生代引用，因此，在新生代GC时只需要扫描卡表位为1的老年代空间。使用这种方式，可以大大加快新生代的回收速度。
 *
 * -----------------------------------------------------------------------------------
 *
 * 【分区算法】
 * 分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间，
 * 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收小区间的数量。
 * 一般来说，在相同条件下，堆空间越大，一次GC所需要的时间就越长，从而产生的停顿也越长（GC产生的停顿请参见4.4节）。为了更好地控制GC产生的停顿时间，将一块大的内
 * 存区域分割成多个小块，根据目标停顿时间，每次合理地回收若干个小区间，而不是回收整个堆空间，从而减少一次GC所产生的停顿。
 *
 * -----------------------------------------------------------------------------------
 * 【串行回收器】
 * 串行回收器可以在新生代和老年代使用，根据不同的堆空间分为新生代串行回收器和老年代串行回收器。
 *
 * [新生代串行回收器]
 * 新生代串行回收器使用复制算法，实现相对简单、逻辑处理特别高效且没有线程切换的开销。
 * 在诸如单CPU处理器等硬件平台不是特别优越的情况下，它的性能表现可以超过并行回收器和并发回收器。
 * -XX:+UseSerialGC参数可以指定使用新生代串行回收器或老年代串行回收器。当虚拟机在Client模式下运行时，它是默认的垃圾回收器。
 *
 *
 *
 * [老年代串行回收器]
 * -XX：+UseSerialGC：新生代、老年代都使用串行回收器。
 * -XX：+UseParNewGC（JDK 9、JDK 10已经删除，因为ParNew需要和CMS搭配工作，而CMS已经被G1替代，不再支持此参数）：新生代使用ParNew回收器，老年代使用串行回收器。
 * -XX：+UseParallelGC：新生代使用ParallelGC回收器，老年代使用串行回收器。
 *
 *
 *
 * -----------------------------------------------------------------------------------
 *  【并行回收器】
 *  使用多个线程同时进行垃圾回收。对于并行能力强的计算机，可以有效减少垃圾回收所需的实际时间。
 *
 *  [新生代ParNew回收器]
 *
 * ParNew回收器是一个工作在新生代的垃圾回收器。
 * 它只是简单地将串行回收器多线程化，它的回收策略、算法及参数和新生代串行回收器一样。
 * ParNew回收器的工作示意图如图5.2所示。ParNew回收器也是独占式的回收器，在回收过程中应用程序会全部暂停。但由于并行回收器使用多线程进行垃圾回收，在并发能力比较强的CPU上，它产生的停顿时间要短于串行回收器，
 * 而在单CPU或者并发能力较弱的系统中，并行回收器的效果不会比串行回收器好，由于多线程的压力，它的实际表现很可能比串行回收器差。
 *
 * -XX：+UseParNewGC（JDK 9、JDK 10已经删除，因为ParNew需要和CMS搭配工作，而CMS已经被G1替代，不再支持此参数）：新生代使用ParNew回收器，老年代使用串行回收器。
 *
 * -XX：+UseConcMarkSweepGC（JDK 9、JDK 10不建议使用，建议使用默认的G1垃圾回收器）：新生代使用ParNew回收器，老年代使用CMS。
 *
 * ParNew回收器工作时的线程数量可以使用-XX:ParallelGCThreads参数指定。一般，最好与CPU数量相当，避免过多的线程数影响垃圾回收性能。
 * 在默认情况下，当CPU数量小于8时，ParallelGCThreads的值等于CPU数量，当CPU数量大于8时，ParallelGCThreads的值等于3+((5×CPU_Count)/8)。
 *
 *
 *  [新生代ParallelGC回收器]
 *  新生代ParallelGC回收器也是使用复制算法的回收器。从表面上看，它和ParNew回收器一样，都是多线程、独占式的回收器。但是，ParallelGC回收器有一个重要的特点：它非常关注系统的吞吐量。
 *  新生代ParallelGC回收器可以使用以下参数启用。
 *
 * -XX：+UseParallelGC：新生代使用ParallelGC回收器，老年代使用串行回收器。
 * -XX：+UseParallelOldGC：新生代使用 ParallelGC 回收器，老年代使用 ParallelOldGC回收器。
 *
 * 控制系统吞吐量参数：
 * -XX：MaxGCPauseMillis：设置最大垃圾回收停顿时间。它的值是一个大于0的整数。ParallelGC 在工作时，会调整 Java 堆大小或者其他参数，尽可能地把停顿时间控制在MaxGCPauseMillis 以内。如果读者希望减少停顿时间而把这个值设得很小，为了达到预期的停顿时间，虚拟机可能会使用一个较小的堆（一个小堆比一个大堆回收快），而这将导致垃圾回收变得很频繁，从而增加垃圾回收总时间，降低吞吐量。
 *
 * -XX：GCTimeRatio：设置吞吐量大小。它的值是一个 0 到 100 之间的整数。假设GCTimeRatio的值为n，那么系统将花费不超过1/（1+n）的时间进行垃圾回收。比如GCTimeRatio等于19（默认值），则系统用于垃圾回收的时间不超过1/（1+19）=5%。默认情况下，它的取值是99，即有不超过1/（1+99）=1%的时间用于垃圾回收。
 *
 * 除此之外，ParallelGC回收器与ParNew回收器另一个不同之处在于，它还支持一种自适应的GC调节策略。
 * 使用-XX:+UseAdaptiveSizePolicy可以打开自适应GC策略。在这种模式下，新生代的大小、eden区和survivor区的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐
 * 量和停顿时间之间的平衡点。在手工调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作。
 *
 * 注意：ParallelGC回收器关注系统吞吐量。可以通过-XX:MaxGCPauseMillis和-XX:GCTimeRatio设置期望的停顿时间和吞吐量。但是鱼和熊掌不可兼得，这两个参数是相互矛盾的，通常如果减少一次收集的最大停顿时间，就会同时减小系统吞吐量，增加系统吞吐量又可能会同时增加一次垃圾回收的最大停顿时间。
 *
 *
 * [老年代ParallelOldGC回收器]
 * 老年代ParallelOldGC回收器也是一种多线程并发的回收器。和新生代ParallelGC回收器一样，它也是一种关注吞吐量的回收器。
 * 从名字上看，它在ParallelGC中间插入了Old，表示这是一个应用于老年代的回收器，并且和ParallelGC新生代回收器搭配使用。
 * -XX:+UseParallelOldGC可以在新生代使用ParallelGC回收器，老年代使用ParallelOldGC回收器。这是一对非常关注吞吐量的垃圾回收器。在对吞吐量敏感的系统中，可以考虑使用
 * -XX:ParallelGCThreads也可以用于设置垃圾回收时的线程数量。
 *
 *
 * -----------------------------------------------------------------------------------
 *
 * 【CMS回收器】
 * 与ParallelGC和ParallelOldGC不同，CMS回收器主要关注系统停顿时间。
 * CMS是Concurrent Mark Sweep的缩写，意为并发标记清除，从名称上就可以得知，它使用的是标记清除法，同时它又是一个使用多线程并行回收的垃圾回收器。
 * 1、初始标记：STW，标记根对象
 * 2、并发标记：标记所有对象
 * 3、预清理：清理前准备以及控制停顿时间
 * 4、重新标记：STW，修正并发标记数据
 * 5、并发清理：清理垃圾
 * 6、并发重置：在垃圾回收完成后，重新初始化CMS数据结构和数据，为下一次垃圾回收做好准备
 *
 *
 * -XX:+UseConcMarkSweepGC 启用CMS回收器
 * -XX:CMSInitiatingOccupancyFraction可以指定当老年代空间使用率达到多少时进行一次CMS垃圾回收
 *
 * 根据应用程序的特点，可以对参数-XX:CMSInitiatingOccupancyFraction进行调优。如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数，可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行回收器。
 *
 * CMS默认启动的并发线程数是(ParallelGCThreads+3)/4
 * 并发线程数量也可以通过
 * -XX:ConcGCThreads或者-XX:ParallelCMSThreads参数手工设定。注意：当CPU资源比较紧张时，受到CMS回收器线程的影响，应用系统的性能在垃圾回收阶段可能会非常糟糕。
 *
 * -XX:+UseCMSCompactAtFullCollection参数可以使CMS在垃圾收集完成后，进行一次内存碎片整理，内存碎片的整理不是并发进行的。
 * -XX:CMSFullGCsBeforeCompaction参数可以用于设定进行多少次CMS回收后，进行一次内存压缩。
 *
 *
 * 有关Class的回收
 * -XX:+CMSClassUnloadingEnabled 打开这个开关后，如果条件允许，系统会使用CMS的机制回收Perm区的Class数据
 * 在使用CMS回收器时，如果需要回收Perm区，那么默认情况下，还需要触发一次Full GC，如果希望使用CMS回收器回收Perm区，则必须打开-XX:+CMSClassUnloadingEnabled开关。
 *
 * -----------------------------------------------------------------------------------
 *
 * 注意：并发是指收集器和应用线程交替执行，并行是指应用程序停止，同时由多个线程一起执行GC。因此并行回收器不是并发的，因为并行回收器执行时，应用程序完全挂起，不存在交替执行。
 *
 *
 * -------------------------------------------------------------------------------------------------------------------------------------
 *
 * 【G1】
 * · 并行性：G1在回收期间，可以由多个GC线程同时工作，有效利用多核计算能力。
 * · 并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，一般来说，不会在整个回收期间完全阻塞应用程序。
 * · 分代 GC：G1 依然是一个分代回收器，但是和之前的回收器不同，它同时兼顾年轻代和老年代，其他回收器或者工作在年轻代，或者工作在老年代。
 * · 空间整理：G1在回收过程中，会进行适当的对象移动，不像CMS，只是简单地标记清理对象，在若干次GC后，CMS必须进行一次碎片整理。而G1不同，它每次回收都会有效地复制对象，减少碎片空间。
 * · 可预见性：由于分区的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，全局停顿也能得到较好的控制。
 *
 * G1回收过程：
 * 1、新生代GC
 * 2、并发标记周期，并发标记周期可以分为以下几步：
 *  2.1、初始标记：（SWT）标记从根节点直接可达的对象。这个阶段会伴随一次新生代GC，它是会产生全局停顿的，应用程序线程在这个阶段必须停止执行。
 *  2.2、根区域扫描：由于初始标记必然会伴随一次新生代GC，所以在初始化标记后，eden区被清空，并且存活对象被移入survivor区。在这个阶段，将扫描由survivor区直接可达的老年代区域，并标记这些直接可达的对象。这个过程是可以和应用程序并发执行的。但是根区域扫描不能和新生代 GC 同时执行（因为根区域扫描依赖 survivor 区的对象，而新生代GC会修改这个区域），因此如果恰巧在此时需要进行新生代GC，就需要等待根区域扫描结束后才能进行。如果发生这种情况，这次新生代GC的时间就会延长。
 *  2.3、并发标记：和CMS类似，并发标记将会扫描并查找整个堆的存活对象，并做好标记。这是一个并发的过程，并且这个过程可以被一次新生代GC打断。
 *  2.4、重新标记：（SWT）和CMS一样，重新标记也是会产生应用程序停顿的。由于在并发标记过程中，应用程序依然在运行，因此标记结果可能需要进行修正，所以在此对上一次的标记结果进行补充。在G1中，这个过程使用SATB（Snapshot-At-The-Beginning）算法完成，即G1会在标记之初为存活对象创建一个快照，这个快照有助于加速重新标记的速度。
 *  2.5、独占清理：（SWT）这个阶段是会引起停顿的。它将计算各个区域的存活对象和 GC 回收比例，并进行排序，识别可供混合回收的区域。在这个阶段，还会更新记忆集（Remebered Set）。该阶段给出了需要被混合回收的区域并进行了标记，在混合回收阶段需要这些信息。
 *  2.6、并发清理：这里会识别并清理完全空闲的区域。它是并发的清理，不会引起停顿。
 *
 * 3、混合回收
 * 4、如果需要，可能会进行FULL GC
 *  和CMS类似，并发回收由于让应用程序和GC线程交替工作，总是不能完全避免在特别繁忙的场合出现在回收过程中内存不充足的情况。当遇到这种情况时，G1也会转入一个Full GC。
 *  此外，如果在混合GC时空间不足，或者在新生代GC时survivor区和老年代无法容纳幸存对象，都会导致一次Full GC。
 *
 * -XX:+UseG1GC标记打开G1的开关
 * -XX:MaxGCPauseMillis，它用于指定目标最大停顿时间。如果任何一次停顿超过这个设置值，G1就会尝试调整新生代和老年代的比例、调整堆大小、调整晋升年龄等，试图达到预设目标。对于性能调优来说，有时候总是鱼和熊掌不可兼得，如果停顿时间缩短，对于新生代来说，这意味着很可能要增加新生代GC的次数。对于老年代来说，为了获得更短的停顿时间，在混合GC时，一次收集的区域数量也会变少，这样无疑增加了进行Full GC的可能性。
 * -XX:ParallelGCThreads，它用于设置并行回收时GC的工作线程数量。
 * -XX:InitiatingHeapOccupancyPercent参数可以指定当整个堆使用率达到多少时，触发并发标记周期的执行。默认值是45，即当整个堆的占用率达到45%时，执行并发标记周期。
 * InitiatingHeapOccupancyPercent一旦设置，始终都不会被G1修改，这意味着G1不会试图改变这个值来满足MaxGCPauseMillis的目标。
 * 如果InitiatingHeapOccupancyPercent值设置得偏大，会导致并发周期迟迟得不到启动，那么引起Full GC的可能性也大大增加，
 * 反之，一个过小的InitiatingHeapOccupancyPercent值会使得并发标记周期执行非常频繁，大量GC线程抢占CPU，导致应用程序的性能有所下降。
 *
 */
public class GC {

    public static void main(String[] args) {
        String aa = "feafejiafoehiaofheioafheuiahfwuieahfueiwahfuiewahfuewiahfewuiafe";
        String bb  = aa.substring(0,2);
        System.out.println(bb);
    }
}
